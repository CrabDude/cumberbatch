{
  "name": "oid",
  "version": "0.5.1",
  "keywords": [
    "object",
    "id",
    "identity",
    "hash",
    "hashcode",
    "objid",
    "oid"
  ],
  "description": "Utilities for object identity and hashing",
  "homepage": "https://github.com/Obvious/oid",
  "repository": {
    "type": "git",
    "url": "https://github.com/Obvious/oid.git"
  },
  "licenses": [
    {
      "type": "Apache 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    }
  ],
  "author": {
    "name": "Dan Bornstein",
    "email": "danfuzz@milk.com",
    "url": "http://www.milk.com/"
  },
  "maintainers": [
    {
      "name": "Dan Bornstein",
      "email": "danfuzz@obvious.com",
      "url": "http://www.milk.com/"
    }
  ],
  "main": "lib/oid.js",
  "engine": {
    "node": ">=0.6.0"
  },
  "scripts": {
    "install": "node-gyp configure build; mkdir -p bin; mv build/Release/*.node bin",
    "test": "node test/test.js"
  },
  "readme": "oid\n===\n\nThis Node module provides a simple utility for object identity hashing\nand two related classes. This can be useful any time you need to do\ntriple-equals (`===`) style comparisons across arbitrary numbers of\nobjects. Instead of doing an O(N^2) set of comparisons, you can\ninstead get the identity hashes of the things you want to compare, and\nuse those in clever ways to whittle down the required comparisons,\noften allowing O(1) implementations.\n\n\nBuilding and Installing\n-----------------------\n\n```shell\nnpm install oid\n```\n\nOr grab the source and\n\n```shell\nnode-waf configure build\n```\n\n**Note**: This module contains native code, and so you will have\nto have a C compiler available. Consult your OS documentation for\ndetails on setting that up.\n\n\nTesting\n-------\n\n```shell\nnpm test\n```\n\nOr\n\n```shell\nnode ./test/test.js\n```\n\nExample\n-------\n\nThis example (also available in the example directory) deduplicates\nthe elements of an array in O(N) time (instead of O(N^2)), by taking\nadvantage of an identity set.\n\n```javascript\nfunction dedup(orig) {\n    var result = [];\n    var elements = oid.createSet();\n\n    for (var i = 0; i < orig.length; i++) {\n        var one = orig[i];\n        if (elements.add(one)) {\n            result.push(one);\n        }\n    }\n\n    return result;\n}\n```\n\nHere's a transcript of a use of this function as well as the more\nfundamental `hash()` function. Note that the literal syntax `[]`\ncreates a new object with a distinct identity each time it is\nexecuted.\n\n```\n> x = []\n[]\n> y = []\n[]\n> z = y\n[]\n> x === y\nfalse\n> oid.hash(x) === oid.hash(y)\nfalse\n> z === y\ntrue\n> oid.hash(z) === oid.hash(y)\ntrue\n> a = dedup([x, y, x, x, y, y, 1, 2, 3, 1, 2, 3, x, y, \"yumminess\"])\n[ [], [], 1, 2, 3, 'yumminess' ]\n> a[0] === x\ntrue\n> a[1] === y\ntrue\n```\n\nUsage\n-----\n\nThis library provides one regular function and two constructors.\n\nTop-Level Functions\n-------------------\n\n### oid.hash(value)\n\nReturn an identity hash of the given value or object. The return value\nfrom two calls to this function are guaranteed to be the same when\ngiven the same input, where \"same\" is the relationship defined by the\ntriple-equals (`===`) operator of JavaScript.\n\nThe return value is furthermore guaranteed to be a positive\n(non-negative and non-zero) integer value.\n\nThe return value is *never* guaranteed to be unique across multiple\nvalues. That is, there are many pairs of values or objects that are\nnot the same but which *do* have the same identity hash. Somewhat\nmore mathematically: `hash(x) !== hash(y)` implies that `x !== y`, but\n`hash(x) === hash(y)` does not imply that `x === y`.\n\nFor normal objects (including arrays, functions, and regular\nexpressions), this returns an arbitrary internally-generated id\nnumber.\n\nFor strings, this returns a hash based on the characters contained in\nthe string. The algorithm used is similar to (but not quite identical\nto) that used by `String.hashCode()` in Java.\n\nFor numbers, this returns a hash based on the numeric value. More specifically,\nit is produced by inspecting the underlying byte representation of the\nvalue. As such, it is not guaranteed to be stable across different\nimplementations of JavaScript.\n\nFor booleans, `null`, and `undefined`, this returns a particular\npredefined value (different for each), which are all prime numbers\nrepresentable with five digits in base ten.\n\n### idmap = oid.createMap()\n\nSee below.\n\n### idset = oid.createSet()\n\nSee below.\n\n\nIdentity Maps\n-------------\n\nAn identity map is a set of key-value associations, where the\nkeys are arbitrary objects or values, compared by identity.\n\n### idmap = oid.createMap()\n\nThis constructs and returns a new identity map.\n\n### idmap.get(key, ifNotFound) => value\n\nGet the value associated with the given key. If there is no mapping\nfor the key, return the `ifNotFound` argument (which defaults to\n`undefined`).\n\n### idmap.set(key, value, ifNotFound) => previousValue\n\nSet the value associated with the given key to the given value, and\nreturn the previously associated value. If there was no previous\nmapping for the key, return the `ifNotFound` argument (which defaults\nto `undefined`).\n\n### idmap.has(key) => boolean\n\nReturn `true` if there is a mapping for the given key or `false`\nif not.\n\n### idmap.remove(key, ifNotFound) => previousValue\n\nRemove the mapping for the given key, returning its formerly\nassociated value or the `ifNotFound` value if the key wasn't formerly\nmapped.\n\n### idmap.size() => int\n\nGet the number of elements in the map.\n\n### idmap.forEach(callback)\n\nCall the given callback as `callback(key, value)` for each association\nin the map. There is no guarantee about what order the callbacks will\nbe made in.\n\nIdentity Sets\n-------------\n\nAn identity set is a set (unordered list of unique elements) of\nobjects / values, where set membership is determined by identity\ncomparison.\n\n### idset = oid.createSet()\n\nThis constructs and returns a new identity set.\n\n### idset.has(value) => boolean\n\nReturn `true` if there the given value is in the set or `false` if not.\n\n### idset.add(value) => boolean\n\nAdd the given value to the set. Returns `true` if this operation\nactually changed the set (that is, `true` if the item wasn't already\nin the set).\n\n### idset.remove(value) => boolean\n\nRemove the given value from the set. Returns `true` if this operation\nactually changed the set (that is, `true` if the item in fact was in\nthe set to begin with).\n\n### idset.size() => int\n\nGet the number of elements in the set.\n\n### idset.forEach(callback)\n\nCall the given callback as `callback(value)` for each element\nof the set. There is no guarantee about what order the callbacks will\nbe made in.\n\nTo Do\n-----\n\n* The two collection classes probably ought to have more iteration methods.\n\n* A weak-key identity map class and a weak-contents identity set class\n  would probably be handy.\n\n* It seems reasonable that this module provide efficient implementations\n  of deep variants of `clone()` and `isEqual()`.\n\n\nContributing\n------------\n\nQuestions, comments, bug reports, and pull requests are all welcome.\nSubmit them at [the project on GitHub](https://github.com/Obvious/oid/).\n\nBug reports that include steps-to-reproduce (including code) are the\nbest. Even better, make them in the form of pull requests that update\nthe test suite. Thanks!\n\nAuthor\n------\n\n[Dan Bornstein](https://github.com/danfuzz)\n([personal website](http://www.milk.com/)), supported by\n[The Obvious Corporation](http://obvious.com/).\n\nLicense\n-------\n\nCopyright 2012 [The Obvious Corporation](http://obvious.com/).\n\nLicensed under the Apache License, Version 2.0. \nSee the top-level file `LICENSE.txt` and\n(http://www.apache.org/licenses/LICENSE-2.0).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Obvious/oid/issues"
  },
  "_id": "oid@0.5.1",
  "dist": {
    "shasum": "3ba86bdaa1c0e673db17cbae854d68dd0c862e44"
  },
  "_from": "oid@0.5",
  "_resolved": "http://registry.npmjs.org/oid/-/oid-0.5.1.tgz"
}
